var o=(a=>(a.PAWN="PAWN",a.KNIGHT="KNIGHT",a.BISHOP="BISHOP",a.QUEEN="QUEEN",a))(o||{}),n=(a=>(a[a.PLAYER_1=1]="PLAYER_1",a[a.PLAYER_2=2]="PLAYER_2",a))(n||{}),p=(a=>(a.IN_PROGRESS="IN_PROGRESS",a.PLAYER_1_WIN="PLAYER_1_WIN",a.PLAYER_2_WIN="PLAYER_2_WIN",a.DRAW="DRAW",a))(p||{}),v=(a=>(a.EASY="EASY",a.HARD="HARD",a))(v||{}),E=(a=>(a.PVP="PVP",a.AI="AI",a))(E||{});class w{static initializeBoard(){const e=[];return e.push({type:o.PAWN,owner:n.PLAYER_1,position:{row:1,col:1},hasMoved:!1,id:"p1-pawn-1"},{type:o.PAWN,owner:n.PLAYER_1,position:{row:1,col:2},hasMoved:!1,id:"p1-pawn-2"},{type:o.PAWN,owner:n.PLAYER_1,position:{row:1,col:3},hasMoved:!1,id:"p1-pawn-3"},{type:o.PAWN,owner:n.PLAYER_1,position:{row:1,col:4},hasMoved:!1,id:"p1-pawn-4"},{type:o.KNIGHT,owner:n.PLAYER_1,position:{row:1,col:5},hasMoved:!1,id:"p1-knight-1"},{type:o.KNIGHT,owner:n.PLAYER_1,position:{row:1,col:6},hasMoved:!1,id:"p1-knight-2"},{type:o.KNIGHT,owner:n.PLAYER_1,position:{row:1,col:7},hasMoved:!1,id:"p1-knight-3"},{type:o.KNIGHT,owner:n.PLAYER_1,position:{row:1,col:8},hasMoved:!1,id:"p1-knight-4"}),e.push({type:o.BISHOP,owner:n.PLAYER_1,position:{row:2,col:1},hasMoved:!1,id:"p1-bishop-1"},{type:o.BISHOP,owner:n.PLAYER_1,position:{row:2,col:2},hasMoved:!1,id:"p1-bishop-2"},{type:o.BISHOP,owner:n.PLAYER_1,position:{row:2,col:3},hasMoved:!1,id:"p1-bishop-3"},{type:o.BISHOP,owner:n.PLAYER_1,position:{row:2,col:4},hasMoved:!1,id:"p1-bishop-4"}),e.push({type:o.BISHOP,owner:n.PLAYER_2,position:{row:7,col:5},hasMoved:!1,id:"p2-bishop-1"},{type:o.BISHOP,owner:n.PLAYER_2,position:{row:7,col:6},hasMoved:!1,id:"p2-bishop-2"},{type:o.BISHOP,owner:n.PLAYER_2,position:{row:7,col:7},hasMoved:!1,id:"p2-bishop-3"},{type:o.BISHOP,owner:n.PLAYER_2,position:{row:7,col:8},hasMoved:!1,id:"p2-bishop-4"}),e.push({type:o.KNIGHT,owner:n.PLAYER_2,position:{row:8,col:1},hasMoved:!1,id:"p2-knight-1"},{type:o.KNIGHT,owner:n.PLAYER_2,position:{row:8,col:2},hasMoved:!1,id:"p2-knight-2"},{type:o.KNIGHT,owner:n.PLAYER_2,position:{row:8,col:3},hasMoved:!1,id:"p2-knight-3"},{type:o.KNIGHT,owner:n.PLAYER_2,position:{row:8,col:4},hasMoved:!1,id:"p2-knight-4"},{type:o.PAWN,owner:n.PLAYER_2,position:{row:8,col:5},hasMoved:!1,id:"p2-pawn-1"},{type:o.PAWN,owner:n.PLAYER_2,position:{row:8,col:6},hasMoved:!1,id:"p2-pawn-2"},{type:o.PAWN,owner:n.PLAYER_2,position:{row:8,col:7},hasMoved:!1,id:"p2-pawn-3"},{type:o.PAWN,owner:n.PLAYER_2,position:{row:8,col:8},hasMoved:!1,id:"p2-pawn-4"}),{pieces:e,currentPlayer:n.PLAYER_1,resourcePoints:{[n.PLAYER_1]:0,[n.PLAYER_2]:0},moveCount:0,capturesSinceLastMove:0}}static applyMove(e,t){const r=e.pieces.map(l=>({...l}));if(t.capturedPiece){const l=r.findIndex(d=>d.id===t.capturedPiece.id);l!==-1&&r.splice(l,1)}const s=r.findIndex(l=>l.id===t.piece.id);s!==-1&&(r[s]={...r[s],position:{...t.to},hasMoved:!0,type:t.isUpgrade?o.QUEEN:r[s].type});const i={...e.resourcePoints};t.capturedPiece&&(i[e.currentPlayer]+=1),t.isUpgrade&&(i[e.currentPlayer]-=2);const c=t.isUpgrade&&t.from.row===t.to.row&&t.from.col===t.to.col,u=c?e.currentPlayer:e.currentPlayer===n.PLAYER_1?n.PLAYER_2:n.PLAYER_1;return{pieces:r,currentPlayer:u,resourcePoints:i,moveCount:c?e.moveCount:e.moveCount+1,capturesSinceLastMove:t.capturedPiece?0:c?e.capturesSinceLastMove:e.capturesSinceLastMove+1}}static getPieceAt(e,t){return t.pieces.find(r=>r.position.row===e.row&&r.position.col===e.col)}static cloneState(e){return{pieces:e.pieces.map(t=>({...t,position:{...t.position}})),currentPlayer:e.currentPlayer,resourcePoints:{...e.resourcePoints},moveCount:e.moveCount,capturesSinceLastMove:e.capturesSinceLastMove}}}class m{static getValidDestinations(e,t){if(e.type!==o.PAWN)return[];const r=[],s=e.owner===n.PLAYER_1?1:-1,{row:i,col:c}=e.position,u={row:i+s,col:c};if(this.isValidForwardMove(u,t)&&(r.push(u),!e.hasMoved)){const l={row:i+2*s,col:c};this.isValidForwardMove(l,t)&&r.push(l)}return r}static isValidForwardMove(e,t){return this.isWithinBounds(e)?!this.isSquareOccupied(e,t):!1}static isWithinBounds(e){return e.row>=1&&e.row<=8&&e.col>=1&&e.col<=8}static isSquareOccupied(e,t){return t.pieces.some(r=>r.position.row===e.row&&r.position.col===e.col)}static shouldAutoPromote(e){if(e.type!==o.PAWN)return!1;const t=e.owner===n.PLAYER_1?8:1;return e.position.row===t}static promoteToQueen(e){return{...e,type:o.QUEEN}}static isValidMove(e,t,r){return this.getValidDestinations(e,r).some(i=>i.row===t.row&&i.col===t.col)}}class I{static getValidDestinations(e,t){if(e.type!==o.KNIGHT)return[];const r=[],{row:s,col:i}=e.position,c=[{row:s+2,col:i+1},{row:s+2,col:i-1},{row:s-2,col:i+1},{row:s-2,col:i-1},{row:s+1,col:i+2},{row:s+1,col:i-2},{row:s-1,col:i+2},{row:s-1,col:i-2}];for(const u of c)this.isValidDestination(u,e,t)&&r.push(u);return r}static isValidDestination(e,t,r){if(!this.isWithinBounds(e))return!1;const s=this.getPieceAt(e,r);return!(s&&s.owner===t.owner)}static isWithinBounds(e){return e.row>=1&&e.row<=8&&e.col>=1&&e.col<=8}static getPieceAt(e,t){return t.pieces.find(r=>r.position.row===e.row&&r.position.col===e.col)}static canCapture(e,t,r){const s=this.getPieceAt(t,r);return s!==void 0&&s.owner!==e.owner}static isValidMove(e,t,r){return this.getValidDestinations(e,r).some(i=>i.row===t.row&&i.col===t.col)}}class A{static getValidDestinations(e,t){if(e.type!==o.BISHOP)return[];const r=[],{row:s,col:i}=e.position,c=[{rowDelta:1,colDelta:1},{rowDelta:1,colDelta:-1},{rowDelta:-1,colDelta:1},{rowDelta:-1,colDelta:-1}];for(const u of c){let l=s+u.rowDelta,d=i+u.colDelta;for(;this.isWithinBounds({row:l,col:d});){const h={row:l,col:d},f=this.getPieceAt(h,t);if(f){f.owner!==e.owner&&r.push(h);break}r.push(h),l+=u.rowDelta,d+=u.colDelta}}return r}static isWithinBounds(e){return e.row>=1&&e.row<=8&&e.col>=1&&e.col<=8}static getPieceAt(e,t){return t.pieces.find(r=>r.position.row===e.row&&r.position.col===e.col)}static isPathClear(e,t,r){const s=t.row-e.row,i=t.col-e.col;if(Math.abs(s)!==Math.abs(i))return!1;const c=s>0?1:-1,u=i>0?1:-1,l=Math.abs(s);for(let d=1;d<l;d++){const h={row:e.row+d*c,col:e.col+d*u};if(this.getPieceAt(h,r))return!1}return!0}static canCapture(e,t,r){const s=this.getPieceAt(t,r);return s!==void 0&&s.owner!==e.owner}static isValidMove(e,t,r){return this.getValidDestinations(e,r).some(i=>i.row===t.row&&i.col===t.col)}}class y{static getValidDestinations(e,t){if(e.type!==o.QUEEN)return[];const r=[],{row:s,col:i}=e.position,c=[{rowDelta:1,colDelta:1},{rowDelta:1,colDelta:-1},{rowDelta:-1,colDelta:1},{rowDelta:-1,colDelta:-1}],l=[{rowDelta:e.owner===n.PLAYER_1?1:-1,colDelta:0}],d=[...c,...l];for(const h of d){let f=s+h.rowDelta,g=i+h.colDelta;for(;this.isWithinBounds({row:f,col:g});){const R={row:f,col:g},L=this.getPieceAt(R,t);if(L){L.owner!==e.owner&&r.push(R);break}r.push(R),f+=h.rowDelta,g+=h.colDelta}}return r}static isWithinBounds(e){return e.row>=1&&e.row<=8&&e.col>=1&&e.col<=8}static getPieceAt(e,t){return t.pieces.find(r=>r.position.row===e.row&&r.position.col===e.col)}static isPathClear(e,t,r){const s=t.row-e.row,i=t.col-e.col;if(!(Math.abs(s)===Math.abs(i)&&s!==0)&&!(i===0&&s!==0))return!1;const l=s===0?0:s>0?1:-1,d=i===0?0:i>0?1:-1,h=Math.max(Math.abs(s),Math.abs(i));for(let f=1;f<h;f++){const g={row:e.row+f*l,col:e.col+f*d};if(this.getPieceAt(g,r))return!1}return!0}static canCapture(e,t,r){const s=this.getPieceAt(t,r);return s!==void 0&&s.owner!==e.owner}static isValidMove(e,t,r){return this.getValidDestinations(e,r).some(i=>i.row===t.row&&i.col===t.col)}}class M{static getValidDestinations(e,t){switch(e.type){case o.PAWN:return m.getValidDestinations(e,t);case o.KNIGHT:return I.getValidDestinations(e,t);case o.BISHOP:return A.getValidDestinations(e,t);case o.QUEEN:return y.getValidDestinations(e,t);default:return[]}}static isValidMove(e,t,r){switch(e.type){case o.PAWN:return m.isValidMove(e,t,r);case o.KNIGHT:return I.isValidMove(e,t,r);case o.BISHOP:return A.isValidMove(e,t,r);case o.QUEEN:return y.isValidMove(e,t,r);default:return!1}}static canCapture(e,t,r){switch(e.type){case o.PAWN:return!1;case o.KNIGHT:return I.canCapture(e,t,r);case o.BISHOP:return A.canCapture(e,t,r);case o.QUEEN:return y.canCapture(e,t,r);default:return!1}}static isPathClear(e,t,r,s){switch(s){case o.BISHOP:return A.isPathClear(e,t,r);case o.QUEEN:return y.isPathClear(e,t,r);case o.KNIGHT:return!0;case o.PAWN:return!0;default:return!1}}}class P{static validateMove(e,t,r){if(e.owner!==r.currentPlayer)return{valid:!1,error:"Invalid: not your turn"};if(!P.isWithinBounds(t))return{valid:!1,error:"Invalid: out of bounds"};if(!M.isValidMove(e,t,r))return{valid:!1,error:"Invalid: illegal move for piece type"};const s=w.getPieceAt(t,r);if(s&&s.owner===e.owner)return{valid:!1,error:"Invalid: blocked"};if(!P.checkPathClear(e,t,r))return{valid:!1,error:"Invalid: obstructed"};const i=P.validateCapture(e,t,r);if(!i.valid)return i;const c={piece:e,from:{...e.position},to:{...t},capturedPiece:s,timestamp:Date.now()};return{valid:!0,newState:w.applyMove(r,c),move:c}}static getValidMoves(e,t){return e.owner!==t.currentPlayer?[]:M.getValidDestinations(e,t)}static isPathClear(e,t,r,s){return M.isPathClear(e,t,r,s)}static checkPathClear(e,t,r){return e.type===o.KNIGHT?!0:e.type===o.BISHOP||e.type===o.QUEEN?M.isPathClear(e.position,t,r,e.type):(e.type===o.PAWN,!0)}static validateCapture(e,t,r){const s=w.getPieceAt(t,r);return s?e.type===o.PAWN?{valid:!1,error:"Invalid: pawns cannot capture"}:s.owner!==e.owner?{valid:!0}:{valid:!1,error:"Invalid: blocked"}:{valid:!0}}static validateUpgrade(e,t){const r=t.pieces.find(c=>c.id===e);if(!r)return{valid:!1,error:"Invalid: piece not found"};if(r.owner!==t.currentPlayer)return{valid:!1,error:"Invalid: not your turn"};if(r.type!==o.PAWN)return{valid:!1,error:"Invalid: only pawns can be upgraded"};if(t.resourcePoints[r.owner]<2)return{valid:!1,error:"Invalid: insufficient resource points (need 2)"};if(r.position.row===1||r.position.row===8)return{valid:!1,error:"Invalid: cannot upgrade pawns on row 1 or row 8"};const s={piece:r,from:{...r.position},to:{...r.position},isUpgrade:!0,timestamp:Date.now()};return{valid:!0,newState:w.applyMove(t,s),move:s}}static isWithinBounds(e){return e.row>=1&&e.row<=8&&e.col>=1&&e.col<=8}}class S{static checkGameStatus(e){if(this.isDrawByFiftyMoveRule(e))return p.DRAW;const t=e.pieces.filter(s=>s.owner===n.PLAYER_1),r=e.pieces.filter(s=>s.owner===n.PLAYER_2);return t.length<3?p.PLAYER_2_WIN:r.length<3?p.PLAYER_1_WIN:this.hasNoValidMoves(e,e.currentPlayer)?e.currentPlayer===n.PLAYER_1?p.PLAYER_2_WIN:p.PLAYER_1_WIN:p.IN_PROGRESS}static hasInsufficientPieces(e,t){return e.pieces.filter(s=>s.owner===t).length<3}static hasNoValidMoves(e,t){const r=e.pieces.filter(s=>s.owner===t);for(const s of r)if(P.getValidMoves(s,e).length>0)return!1;return!0}static isDrawByFiftyMoveRule(e){return e.capturesSinceLastMove>=50}static isGameOver(e){return this.checkGameStatus(e)!==p.IN_PROGRESS}static getWinner(e){const t=this.checkGameStatus(e);return t===p.PLAYER_1_WIN?n.PLAYER_1:t===p.PLAYER_2_WIN?n.PLAYER_2:null}static getOutcomeMessage(e){switch(this.checkGameStatus(e)){case p.PLAYER_1_WIN:return"Player 1 wins!";case p.PLAYER_2_WIN:return"Player 2 wins!";case p.DRAW:return"Game is a draw (50 moves without capture)";case p.IN_PROGRESS:return"Game in progress";default:return"Unknown game status"}}}class N{constructor(e){this.currentState=e||w.initializeBoard(),this.moveHistory=[],this.stateHistory=[w.cloneState(this.currentState)]}getCurrentState(){return w.cloneState(this.currentState)}getMoveHistory(){return[...this.moveHistory]}recordMove(e){this.currentState=w.applyMove(this.currentState,e),this.moveHistory.push(e),this.stateHistory.push(w.cloneState(this.currentState))}undoMoves(e){if(e<1)return!1;const t=Math.min(e,this.moveHistory.length,3);return t===0?!1:(this.moveHistory.splice(-t),this.stateHistory.splice(-t),this.stateHistory.length>0&&(this.currentState=w.cloneState(this.stateHistory[this.stateHistory.length-1])),!0)}getStateAtMove(e){return e<0||e>=this.stateHistory.length?null:w.cloneState(this.stateHistory[e])}reset(){this.currentState=w.initializeBoard(),this.moveHistory=[],this.stateHistory=[w.cloneState(this.currentState)]}getMoveCount(){return this.moveHistory.length}canUndo(e=1){return this.moveHistory.length>=e&&e<=3}canUpgradePiece(e){const t=this.currentState.pieces.find(r=>r.id===e);return!(!t||t.type!==o.PAWN||t.owner!==this.currentState.currentPlayer||this.currentState.resourcePoints[t.owner]<2||t.position.row===1||t.position.row===8)}getResourcePoints(e){return this.currentState.resourcePoints[e]}upgradePiece(e){if(!this.canUpgradePiece(e))return null;const t=this.currentState.pieces.find(s=>s.id===e);if(!t)return null;const r={piece:{...t},from:{...t.position},to:{...t.position},isUpgrade:!0,timestamp:Date.now()};return this.recordMove(r),r}getGameStatus(){return S.checkGameStatus(this.currentState)}isGameOver(){return S.isGameOver(this.currentState)}getWinner(){return S.getWinner(this.currentState)}getOutcomeMessage(){return S.getOutcomeMessage(this.currentState)}canMakeMove(){return!this.isGameOver()}}const _=class _{static getPieceValue(e){switch(e){case o.PAWN:return 10;case o.KNIGHT:return 30;case o.BISHOP:return 30;case o.QUEEN:return 50}}static orderMoves(e,t){return e.sort((r,s)=>{const i=r.capturedPiece!==void 0,c=s.capturedPiece!==void 0;if(i&&!c)return-1;if(!i&&c)return 1;if(i&&c){const f=this.getPieceValue(r.capturedPiece.type),g=this.getPieceValue(s.capturedPiece.type);if(f!==g)return g-f}const u=r.isUpgrade===!0,l=s.isUpgrade===!0;if(u&&!l)return-1;if(!u&&l)return 1;const d=this.getForwardProgress(r),h=this.getForwardProgress(s);return d!==h?h-d:0})}static getForwardProgress(e){const t=e.piece,r=e.from.row,s=e.to.row;return t.owner===n.PLAYER_1?s-r:r-s}static generateMoves(e,t){const r=[],s=e.pieces.filter(i=>i.owner===t);for(const i of s){const c=M.getValidDestinations(i,e);for(const u of c){const l=P.validateMove(i,u,e);l.valid&&l.move&&r.push(l.move)}}return r}static getDepthForDifficulty(e){switch(e){case v.EASY:return 4;case v.HARD:return 6}}static calculateBestMove(e,t){this.getDepthForDifficulty(t);const r=Date.now(),s=this.generateMoves(e,e.currentPlayer);if(s.length===0)return null;let c=this.orderMoves(s,e)[0];return Date.now()-r>=this.TIME_LIMIT_MS,c}};_.TIME_LIMIT_MS=5e3;let D=_;class Y{constructor(e){this.config=e||{mode:E.PVP,difficulty:v.EASY},this.stateManager=new N}initializeGame(e){this.config=e,this.stateManager.reset()}getConfig(){return{...this.config}}getGameState(){return this.stateManager.getCurrentState()}getGameStatus(){return this.stateManager.getGameStatus()}getMoveHistory(){return this.stateManager.getMoveHistory()}isGameOver(){return this.stateManager.isGameOver()}getWinner(){return this.stateManager.getWinner()}getOutcomeMessage(){return this.stateManager.getOutcomeMessage()}attemptMove(e,t){if(this.isGameOver())return{valid:!1,error:"Invalid: game over"};const r=this.stateManager.getCurrentState(),s=r.pieces.find(c=>c.position.row===e.row&&c.position.col===e.col);if(!s)return{valid:!1,error:"Invalid: no piece at source position"};const i=P.validateMove(s,t,r);return i.valid&&i.move&&(this.stateManager.recordMove(i.move),this.shouldTriggerAI()&&this.triggerAIMove()),i}attemptUpgrade(e){if(this.isGameOver())return{valid:!1,error:"Invalid: game over"};const t=this.stateManager.getCurrentState(),r=P.validateUpgrade(e,t);return r.valid&&r.move&&this.stateManager.recordMove(r.move),r}undoMove(e=1){return this.isGameOver()?!1:this.stateManager.undoMoves(e)}switchMode(e){this.config=e,this.stateManager.reset()}restartGame(){this.stateManager.reset()}newGame(e){this.config=e,this.stateManager.reset()}getStateAtMove(e){return this.stateManager.getStateAtMove(e)}canUndo(e=1){return this.stateManager.canUndo(e)}canUpgradePiece(e){return this.stateManager.canUpgradePiece(e)}getResourcePoints(e){return this.stateManager.getResourcePoints(e)}shouldTriggerAI(){return!(this.config.mode!==E.AI||this.stateManager.getCurrentState().currentPlayer!==n.PLAYER_2||this.isGameOver())}triggerAIMove(){const e=this.stateManager.getCurrentState(),t=this.config.difficulty||v.EASY,r=D.calculateBestMove(e,t);r&&this.stateManager.recordMove(r)}getCurrentPlayer(){return this.stateManager.getCurrentState().currentPlayer}isAITurn(){return this.config.mode===E.AI&&this.getCurrentPlayer()===n.PLAYER_2}getGameMode(){return this.config.mode}getDifficulty(){return this.config.difficulty||v.EASY}getValidMoves(e){const t=this.stateManager.getCurrentState();return P.getValidMoves(e,t)}}export{v as D,p as G,o as P,n as a,E as b,Y as c};
//# sourceMappingURL=game-logic-DjUrrTGZ.js.map
