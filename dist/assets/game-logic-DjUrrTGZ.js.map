{"version":3,"file":"game-logic-DjUrrTGZ.js","sources":["../../src/types/index.ts","../../src/logic/gameState.ts","../../src/logic/pawnLogic.ts","../../src/logic/knightLogic.ts","../../src/logic/bishopLogic.ts","../../src/logic/queenLogic.ts","../../src/logic/pieceLogic.ts","../../src/logic/moveValidator.ts","../../src/logic/winConditions.ts","../../src/logic/gameStateManager.ts","../../src/logic/aiEngine.ts","../../src/logic/gameController.ts"],"sourcesContent":["export enum PieceType {\n  PAWN = 'PAWN',\n  KNIGHT = 'KNIGHT',\n  BISHOP = 'BISHOP',\n  QUEEN = 'QUEEN'\n}\n\nexport enum Player {\n  PLAYER_1 = 1,\n  PLAYER_2 = 2\n}\n\nexport interface Position {\n  row: number;  // 1-8\n  col: number;  // 1-8\n}\n\nexport interface Piece {\n  type: PieceType;\n  owner: Player;\n  position: Position;\n  hasMoved: boolean;\n  id: string;\n}\n\nexport interface BoardState {\n  pieces: Piece[];\n  currentPlayer: Player;\n  resourcePoints: { [Player.PLAYER_1]: number; [Player.PLAYER_2]: number };\n  moveCount: number;\n  capturesSinceLastMove: number;\n}\n\nexport interface Move {\n  piece: Piece;\n  from: Position;\n  to: Position;\n  capturedPiece?: Piece;\n  isUpgrade?: boolean;\n  timestamp: number;\n}\n\nexport interface MoveResult {\n  valid: boolean;\n  error?: string;\n  newState?: BoardState;\n  move?: Move;\n}\n\nexport enum GameStatus {\n  IN_PROGRESS = 'IN_PROGRESS',\n  PLAYER_1_WIN = 'PLAYER_1_WIN',\n  PLAYER_2_WIN = 'PLAYER_2_WIN',\n  DRAW = 'DRAW'\n}\n\nexport enum Difficulty {\n  EASY = 'EASY',\n  HARD = 'HARD'\n}\n\nexport enum GameMode {\n  PVP = 'PVP',\n  AI = 'AI'\n}\n\nexport interface GameConfig {\n  mode: GameMode;\n  difficulty?: Difficulty;\n}\n","import { BoardState, Piece, PieceType, Player, Position, Move } from '../types';\n\n/**\n * Game State Manager\n * Handles board initialization, state transitions, move history, and undo functionality\n */\nexport class GameState {\n  /**\n   * Initialize a new game board with starting positions\n   */\n  static initializeBoard(): BoardState {\n    const pieces: Piece[] = [];\n\n    // Player 1 pieces (rows 1-2)\n    // Row 1: 4 Pawns, 4 Knights\n    pieces.push(\n      { type: PieceType.PAWN, owner: Player.PLAYER_1, position: { row: 1, col: 1 }, hasMoved: false, id: 'p1-pawn-1' },\n      { type: PieceType.PAWN, owner: Player.PLAYER_1, position: { row: 1, col: 2 }, hasMoved: false, id: 'p1-pawn-2' },\n      { type: PieceType.PAWN, owner: Player.PLAYER_1, position: { row: 1, col: 3 }, hasMoved: false, id: 'p1-pawn-3' },\n      { type: PieceType.PAWN, owner: Player.PLAYER_1, position: { row: 1, col: 4 }, hasMoved: false, id: 'p1-pawn-4' },\n      { type: PieceType.KNIGHT, owner: Player.PLAYER_1, position: { row: 1, col: 5 }, hasMoved: false, id: 'p1-knight-1' },\n      { type: PieceType.KNIGHT, owner: Player.PLAYER_1, position: { row: 1, col: 6 }, hasMoved: false, id: 'p1-knight-2' },\n      { type: PieceType.KNIGHT, owner: Player.PLAYER_1, position: { row: 1, col: 7 }, hasMoved: false, id: 'p1-knight-3' },\n      { type: PieceType.KNIGHT, owner: Player.PLAYER_1, position: { row: 1, col: 8 }, hasMoved: false, id: 'p1-knight-4' }\n    );\n\n    // Row 2: 4 Bishops\n    pieces.push(\n      { type: PieceType.BISHOP, owner: Player.PLAYER_1, position: { row: 2, col: 1 }, hasMoved: false, id: 'p1-bishop-1' },\n      { type: PieceType.BISHOP, owner: Player.PLAYER_1, position: { row: 2, col: 2 }, hasMoved: false, id: 'p1-bishop-2' },\n      { type: PieceType.BISHOP, owner: Player.PLAYER_1, position: { row: 2, col: 3 }, hasMoved: false, id: 'p1-bishop-3' },\n      { type: PieceType.BISHOP, owner: Player.PLAYER_1, position: { row: 2, col: 4 }, hasMoved: false, id: 'p1-bishop-4' }\n    );\n\n    // Player 2 pieces (rows 7-8)\n    // Row 7: 4 Bishops\n    pieces.push(\n      { type: PieceType.BISHOP, owner: Player.PLAYER_2, position: { row: 7, col: 5 }, hasMoved: false, id: 'p2-bishop-1' },\n      { type: PieceType.BISHOP, owner: Player.PLAYER_2, position: { row: 7, col: 6 }, hasMoved: false, id: 'p2-bishop-2' },\n      { type: PieceType.BISHOP, owner: Player.PLAYER_2, position: { row: 7, col: 7 }, hasMoved: false, id: 'p2-bishop-3' },\n      { type: PieceType.BISHOP, owner: Player.PLAYER_2, position: { row: 7, col: 8 }, hasMoved: false, id: 'p2-bishop-4' }\n    );\n\n    // Row 8: 4 Pawns, 4 Knights\n    pieces.push(\n      { type: PieceType.KNIGHT, owner: Player.PLAYER_2, position: { row: 8, col: 1 }, hasMoved: false, id: 'p2-knight-1' },\n      { type: PieceType.KNIGHT, owner: Player.PLAYER_2, position: { row: 8, col: 2 }, hasMoved: false, id: 'p2-knight-2' },\n      { type: PieceType.KNIGHT, owner: Player.PLAYER_2, position: { row: 8, col: 3 }, hasMoved: false, id: 'p2-knight-3' },\n      { type: PieceType.KNIGHT, owner: Player.PLAYER_2, position: { row: 8, col: 4 }, hasMoved: false, id: 'p2-knight-4' },\n      { type: PieceType.PAWN, owner: Player.PLAYER_2, position: { row: 8, col: 5 }, hasMoved: false, id: 'p2-pawn-1' },\n      { type: PieceType.PAWN, owner: Player.PLAYER_2, position: { row: 8, col: 6 }, hasMoved: false, id: 'p2-pawn-2' },\n      { type: PieceType.PAWN, owner: Player.PLAYER_2, position: { row: 8, col: 7 }, hasMoved: false, id: 'p2-pawn-3' },\n      { type: PieceType.PAWN, owner: Player.PLAYER_2, position: { row: 8, col: 8 }, hasMoved: false, id: 'p2-pawn-4' }\n    );\n\n    return {\n      pieces,\n      currentPlayer: Player.PLAYER_1,\n      resourcePoints: {\n        [Player.PLAYER_1]: 0,\n        [Player.PLAYER_2]: 0\n      },\n      moveCount: 0,\n      capturesSinceLastMove: 0\n    };\n  }\n\n  /**\n   * Apply a move to the board state (immutable)\n   */\n  static applyMove(state: BoardState, move: Move): BoardState {\n    const newPieces = state.pieces.map(p => ({ ...p }));\n\n    // Remove captured piece if any\n    if (move.capturedPiece) {\n      const capturedIndex = newPieces.findIndex(p => p.id === move.capturedPiece!.id);\n      if (capturedIndex !== -1) {\n        newPieces.splice(capturedIndex, 1);\n      }\n    }\n\n    // Update moving piece position and hasMoved flag\n    const movingPieceIndex = newPieces.findIndex(p => p.id === move.piece.id);\n    if (movingPieceIndex !== -1) {\n      newPieces[movingPieceIndex] = {\n        ...newPieces[movingPieceIndex],\n        position: { ...move.to },\n        hasMoved: true,\n        type: move.isUpgrade ? PieceType.QUEEN : newPieces[movingPieceIndex].type\n      };\n    }\n\n    // Calculate new resource points\n    const newResourcePoints = { ...state.resourcePoints };\n    if (move.capturedPiece) {\n      newResourcePoints[state.currentPlayer] += 1;\n    }\n    if (move.isUpgrade) {\n      newResourcePoints[state.currentPlayer] -= 2;\n    }\n\n    // Switch player (unless it's just an upgrade without movement)\n    const isUpgradeOnly = move.isUpgrade && move.from.row === move.to.row && move.from.col === move.to.col;\n    const nextPlayer = isUpgradeOnly ? state.currentPlayer : (state.currentPlayer === Player.PLAYER_1 ? Player.PLAYER_2 : Player.PLAYER_1);\n\n    return {\n      pieces: newPieces,\n      currentPlayer: nextPlayer,\n      resourcePoints: newResourcePoints,\n      moveCount: isUpgradeOnly ? state.moveCount : state.moveCount + 1,\n      capturesSinceLastMove: move.capturedPiece ? 0 : (isUpgradeOnly ? state.capturesSinceLastMove : state.capturesSinceLastMove + 1)\n    };\n  }\n\n  /**\n   * Get piece at a specific position\n   */\n  static getPieceAt(position: Position, state: BoardState): Piece | undefined {\n    return state.pieces.find(\n      p => p.position.row === position.row && p.position.col === position.col\n    );\n  }\n\n  /**\n   * Clone board state (deep copy)\n   */\n  static cloneState(state: BoardState): BoardState {\n    return {\n      pieces: state.pieces.map(p => ({ ...p, position: { ...p.position } })),\n      currentPlayer: state.currentPlayer,\n      resourcePoints: { ...state.resourcePoints },\n      moveCount: state.moveCount,\n      capturesSinceLastMove: state.capturesSinceLastMove\n    };\n  }\n}\n","import { Piece, Position, BoardState, Player, PieceType } from '../types';\n\nexport class PawnLogic {\n  /**\n   * Get valid destination positions for a Pawn\n   */\n  static getValidDestinations(pawn: Piece, board: BoardState): Position[] {\n    if (pawn.type !== PieceType.PAWN) {\n      return [];\n    }\n\n    const validPositions: Position[] = [];\n    const direction = pawn.owner === Player.PLAYER_1 ? 1 : -1;\n    const { row, col } = pawn.position;\n\n    // Forward 1 square\n    const oneSquareAhead = { row: row + direction, col };\n    if (this.isValidForwardMove(oneSquareAhead, board)) {\n      validPositions.push(oneSquareAhead);\n\n      // Forward 2 squares (only if hasn't moved and 1 square ahead is clear)\n      if (!pawn.hasMoved) {\n        const twoSquaresAhead = { row: row + (2 * direction), col };\n        if (this.isValidForwardMove(twoSquaresAhead, board)) {\n          validPositions.push(twoSquaresAhead);\n        }\n      }\n    }\n\n    return validPositions;\n  }\n\n  /**\n   * Check if a forward move is valid (within bounds and not occupied)\n   */\n  private static isValidForwardMove(position: Position, board: BoardState): boolean {\n    // Check bounds\n    if (!this.isWithinBounds(position)) {\n      return false;\n    }\n\n    // Check if square is occupied\n    return !this.isSquareOccupied(position, board);\n  }\n\n  /**\n   * Check if position is within board boundaries\n   */\n  private static isWithinBounds(position: Position): boolean {\n    return position.row >= 1 && position.row <= 8 && \n           position.col >= 1 && position.col <= 8;\n  }\n\n  /**\n   * Check if a square is occupied by any piece\n   */\n  private static isSquareOccupied(position: Position, board: BoardState): boolean {\n    return board.pieces.some(\n      piece => piece.position.row === position.row && \n               piece.position.col === position.col\n    );\n  }\n\n  /**\n   * Check if Pawn should auto-promote to Queen\n   */\n  static shouldAutoPromote(pawn: Piece): boolean {\n    if (pawn.type !== PieceType.PAWN) {\n      return false;\n    }\n\n    // Player 1 promotes at row 8, Player 2 promotes at row 1\n    const promotionRow = pawn.owner === Player.PLAYER_1 ? 8 : 1;\n    return pawn.position.row === promotionRow;\n  }\n\n  /**\n   * Promote Pawn to Queen\n   */\n  static promoteToQueen(pawn: Piece): Piece {\n    return {\n      ...pawn,\n      type: PieceType.QUEEN\n    };\n  }\n\n  /**\n   * Validate if a move is legal for a Pawn\n   */\n  static isValidMove(pawn: Piece, to: Position, board: BoardState): boolean {\n    const validDestinations = this.getValidDestinations(pawn, board);\n    return validDestinations.some(\n      pos => pos.row === to.row && pos.col === to.col\n    );\n  }\n}\n","import { Piece, Position, BoardState, PieceType } from '../types';\n\nexport class KnightLogic {\n  /**\n   * Get valid destination positions for a Knight\n   */\n  static getValidDestinations(knight: Piece, board: BoardState): Position[] {\n    if (knight.type !== PieceType.KNIGHT) {\n      return [];\n    }\n\n    const validPositions: Position[] = [];\n    const { row, col } = knight.position;\n\n    // All 8 possible L-shape moves\n    const moves = [\n      { row: row + 2, col: col + 1 },\n      { row: row + 2, col: col - 1 },\n      { row: row - 2, col: col + 1 },\n      { row: row - 2, col: col - 1 },\n      { row: row + 1, col: col + 2 },\n      { row: row + 1, col: col - 2 },\n      { row: row - 1, col: col + 2 },\n      { row: row - 1, col: col - 2 }\n    ];\n\n    for (const move of moves) {\n      if (this.isValidDestination(move, knight, board)) {\n        validPositions.push(move);\n      }\n    }\n\n    return validPositions;\n  }\n\n  /**\n   * Check if a destination is valid for the Knight\n   */\n  private static isValidDestination(\n    position: Position, \n    knight: Piece, \n    board: BoardState\n  ): boolean {\n    // Check bounds\n    if (!this.isWithinBounds(position)) {\n      return false;\n    }\n\n    // Check if square is occupied by friendly piece\n    const pieceAtDestination = this.getPieceAt(position, board);\n    if (pieceAtDestination && pieceAtDestination.owner === knight.owner) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Check if position is within board boundaries\n   */\n  private static isWithinBounds(position: Position): boolean {\n    return position.row >= 1 && position.row <= 8 && \n           position.col >= 1 && position.col <= 8;\n  }\n\n  /**\n   * Get piece at a specific position\n   */\n  private static getPieceAt(position: Position, board: BoardState): Piece | undefined {\n    return board.pieces.find(\n      piece => piece.position.row === position.row && \n               piece.position.col === position.col\n    );\n  }\n\n  /**\n   * Check if Knight can capture at the destination\n   */\n  static canCapture(knight: Piece, target: Position, board: BoardState): boolean {\n    const pieceAtTarget = this.getPieceAt(target, board);\n    return pieceAtTarget !== undefined && pieceAtTarget.owner !== knight.owner;\n  }\n\n  /**\n   * Validate if a move is legal for a Knight\n   */\n  static isValidMove(knight: Piece, to: Position, board: BoardState): boolean {\n    const validDestinations = this.getValidDestinations(knight, board);\n    return validDestinations.some(\n      pos => pos.row === to.row && pos.col === to.col\n    );\n  }\n}\n","import { Piece, Position, BoardState, PieceType } from '../types';\n\nexport class BishopLogic {\n  /**\n   * Get valid destination positions for a Bishop\n   */\n  static getValidDestinations(bishop: Piece, board: BoardState): Position[] {\n    if (bishop.type !== PieceType.BISHOP) {\n      return [];\n    }\n\n    const validPositions: Position[] = [];\n    const { row, col } = bishop.position;\n\n    // Four diagonal directions\n    const directions = [\n      { rowDelta: 1, colDelta: 1 },   // Up-right\n      { rowDelta: 1, colDelta: -1 },  // Up-left\n      { rowDelta: -1, colDelta: 1 },  // Down-right\n      { rowDelta: -1, colDelta: -1 }  // Down-left\n    ];\n\n    for (const direction of directions) {\n      let currentRow = row + direction.rowDelta;\n      let currentCol = col + direction.colDelta;\n\n      while (this.isWithinBounds({ row: currentRow, col: currentCol })) {\n        const currentPos = { row: currentRow, col: currentCol };\n        const pieceAtPos = this.getPieceAt(currentPos, board);\n\n        if (pieceAtPos) {\n          // If opponent piece, can capture (but stop here)\n          if (pieceAtPos.owner !== bishop.owner) {\n            validPositions.push(currentPos);\n          }\n          // Stop in either case (friendly or opponent piece)\n          break;\n        }\n\n        // Empty square - valid move\n        validPositions.push(currentPos);\n\n        // Continue in this direction\n        currentRow += direction.rowDelta;\n        currentCol += direction.colDelta;\n      }\n    }\n\n    return validPositions;\n  }\n\n  /**\n   * Check if position is within board boundaries\n   */\n  private static isWithinBounds(position: Position): boolean {\n    return position.row >= 1 && position.row <= 8 && \n           position.col >= 1 && position.col <= 8;\n  }\n\n  /**\n   * Get piece at a specific position\n   */\n  private static getPieceAt(position: Position, board: BoardState): Piece | undefined {\n    return board.pieces.find(\n      piece => piece.position.row === position.row && \n               piece.position.col === position.col\n    );\n  }\n\n  /**\n   * Check if path is clear between two positions (diagonal only)\n   */\n  static isPathClear(from: Position, to: Position, board: BoardState): boolean {\n    const rowDiff = to.row - from.row;\n    const colDiff = to.col - from.col;\n\n    // Must be diagonal move\n    if (Math.abs(rowDiff) !== Math.abs(colDiff)) {\n      return false;\n    }\n\n    const rowStep = rowDiff > 0 ? 1 : -1;\n    const colStep = colDiff > 0 ? 1 : -1;\n    const steps = Math.abs(rowDiff);\n\n    // Check each square along the path (excluding start and end)\n    for (let i = 1; i < steps; i++) {\n      const checkPos = {\n        row: from.row + (i * rowStep),\n        col: from.col + (i * colStep)\n      };\n\n      if (this.getPieceAt(checkPos, board)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Check if Bishop can capture at the destination\n   */\n  static canCapture(bishop: Piece, target: Position, board: BoardState): boolean {\n    const pieceAtTarget = this.getPieceAt(target, board);\n    return pieceAtTarget !== undefined && pieceAtTarget.owner !== bishop.owner;\n  }\n\n  /**\n   * Validate if a move is legal for a Bishop\n   */\n  static isValidMove(bishop: Piece, to: Position, board: BoardState): boolean {\n    const validDestinations = this.getValidDestinations(bishop, board);\n    return validDestinations.some(\n      pos => pos.row === to.row && pos.col === to.col\n    );\n  }\n}\n","import { Piece, Position, BoardState, PieceType, Player } from '../types';\n\nexport class QueenLogic {\n  /**\n   * Get valid destination positions for a Queen\n   * Queen combines diagonal movement (like Bishop) and forward movement (like extended Pawn)\n   */\n  static getValidDestinations(queen: Piece, board: BoardState): Position[] {\n    if (queen.type !== PieceType.QUEEN) {\n      return [];\n    }\n\n    const validPositions: Position[] = [];\n    const { row, col } = queen.position;\n\n    // Diagonal directions (like Bishop)\n    const diagonalDirections = [\n      { rowDelta: 1, colDelta: 1 },   // Up-right\n      { rowDelta: 1, colDelta: -1 },  // Up-left\n      { rowDelta: -1, colDelta: 1 },  // Down-right\n      { rowDelta: -1, colDelta: -1 }  // Down-left\n    ];\n\n    // Forward direction (based on player)\n    const forwardDirection = queen.owner === Player.PLAYER_1 ? 1 : -1;\n    const forwardDirections = [\n      { rowDelta: forwardDirection, colDelta: 0 }  // Forward\n    ];\n\n    // Combine all directions\n    const allDirections = [...diagonalDirections, ...forwardDirections];\n\n    for (const direction of allDirections) {\n      let currentRow = row + direction.rowDelta;\n      let currentCol = col + direction.colDelta;\n\n      while (this.isWithinBounds({ row: currentRow, col: currentCol })) {\n        const currentPos = { row: currentRow, col: currentCol };\n        const pieceAtPos = this.getPieceAt(currentPos, board);\n\n        if (pieceAtPos) {\n          // If opponent piece, can capture (but stop here)\n          if (pieceAtPos.owner !== queen.owner) {\n            validPositions.push(currentPos);\n          }\n          // Stop in either case (friendly or opponent piece)\n          break;\n        }\n\n        // Empty square - valid move\n        validPositions.push(currentPos);\n\n        // Continue in this direction\n        currentRow += direction.rowDelta;\n        currentCol += direction.colDelta;\n      }\n    }\n\n    return validPositions;\n  }\n\n  /**\n   * Check if position is within board boundaries\n   */\n  private static isWithinBounds(position: Position): boolean {\n    return position.row >= 1 && position.row <= 8 && \n           position.col >= 1 && position.col <= 8;\n  }\n\n  /**\n   * Get piece at a specific position\n   */\n  private static getPieceAt(position: Position, board: BoardState): Piece | undefined {\n    return board.pieces.find(\n      piece => piece.position.row === position.row && \n               piece.position.col === position.col\n    );\n  }\n\n  /**\n   * Check if path is clear between two positions\n   */\n  static isPathClear(from: Position, to: Position, board: BoardState): boolean {\n    const rowDiff = to.row - from.row;\n    const colDiff = to.col - from.col;\n\n    // Determine if move is diagonal or forward\n    const isDiagonal = Math.abs(rowDiff) === Math.abs(colDiff) && rowDiff !== 0;\n    const isForward = colDiff === 0 && rowDiff !== 0;\n\n    if (!isDiagonal && !isForward) {\n      return false;\n    }\n\n    const rowStep = rowDiff === 0 ? 0 : (rowDiff > 0 ? 1 : -1);\n    const colStep = colDiff === 0 ? 0 : (colDiff > 0 ? 1 : -1);\n    const steps = Math.max(Math.abs(rowDiff), Math.abs(colDiff));\n\n    // Check each square along the path (excluding start and end)\n    for (let i = 1; i < steps; i++) {\n      const checkPos = {\n        row: from.row + (i * rowStep),\n        col: from.col + (i * colStep)\n      };\n\n      if (this.getPieceAt(checkPos, board)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Check if Queen can capture at the destination\n   */\n  static canCapture(queen: Piece, target: Position, board: BoardState): boolean {\n    const pieceAtTarget = this.getPieceAt(target, board);\n    return pieceAtTarget !== undefined && pieceAtTarget.owner !== queen.owner;\n  }\n\n  /**\n   * Validate if a move is legal for a Queen\n   */\n  static isValidMove(queen: Piece, to: Position, board: BoardState): boolean {\n    const validDestinations = this.getValidDestinations(queen, board);\n    return validDestinations.some(\n      pos => pos.row === to.row && pos.col === to.col\n    );\n  }\n}\n","import { Piece, Position, BoardState, PieceType } from '../types';\nimport { PawnLogic } from './pawnLogic';\nimport { KnightLogic } from './knightLogic';\nimport { BishopLogic } from './bishopLogic';\nimport { QueenLogic } from './queenLogic';\n\n/**\n * Unified interface for piece movement logic\n */\nexport class PieceLogic {\n  /**\n   * Get valid destination positions for any piece type\n   */\n  static getValidDestinations(piece: Piece, board: BoardState): Position[] {\n    switch (piece.type) {\n      case PieceType.PAWN:\n        return PawnLogic.getValidDestinations(piece, board);\n      case PieceType.KNIGHT:\n        return KnightLogic.getValidDestinations(piece, board);\n      case PieceType.BISHOP:\n        return BishopLogic.getValidDestinations(piece, board);\n      case PieceType.QUEEN:\n        return QueenLogic.getValidDestinations(piece, board);\n      default:\n        return [];\n    }\n  }\n\n  /**\n   * Validate if a move is legal for any piece type\n   */\n  static isValidMove(piece: Piece, to: Position, board: BoardState): boolean {\n    switch (piece.type) {\n      case PieceType.PAWN:\n        return PawnLogic.isValidMove(piece, to, board);\n      case PieceType.KNIGHT:\n        return KnightLogic.isValidMove(piece, to, board);\n      case PieceType.BISHOP:\n        return BishopLogic.isValidMove(piece, to, board);\n      case PieceType.QUEEN:\n        return QueenLogic.isValidMove(piece, to, board);\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Check if a piece can capture at the target position\n   */\n  static canCapture(piece: Piece, target: Position, board: BoardState): boolean {\n    switch (piece.type) {\n      case PieceType.PAWN:\n        return false; // Pawns cannot capture in this game\n      case PieceType.KNIGHT:\n        return KnightLogic.canCapture(piece, target, board);\n      case PieceType.BISHOP:\n        return BishopLogic.canCapture(piece, target, board);\n      case PieceType.QUEEN:\n        return QueenLogic.canCapture(piece, target, board);\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Check if path is clear between two positions\n   * (Only applicable for Bishop and Queen)\n   */\n  static isPathClear(from: Position, to: Position, board: BoardState, pieceType: PieceType): boolean {\n    switch (pieceType) {\n      case PieceType.BISHOP:\n        return BishopLogic.isPathClear(from, to, board);\n      case PieceType.QUEEN:\n        return QueenLogic.isPathClear(from, to, board);\n      case PieceType.KNIGHT:\n        return true; // Knights jump over pieces\n      case PieceType.PAWN:\n        // Pawns have their own obstruction logic in getValidDestinations\n        return true;\n      default:\n        return false;\n    }\n  }\n}\n\n// Export individual piece logic classes for direct access if needed\nexport { PawnLogic, KnightLogic, BishopLogic, QueenLogic };\n","import { Piece, Position, BoardState, MoveResult, PieceType, Player } from '../types';\nimport { PieceLogic } from './pieceLogic';\nimport { GameState } from './gameState';\n\n/**\n * MoveValidator\n * Validates moves against piece-specific rules, checks path obstructions,\n * verifies destination validity, and handles capture logic\n */\nexport class MoveValidator {\n  /**\n   * Validate a move and return detailed result with error messages\n   */\n  static validateMove(piece: Piece, to: Position, board: BoardState): MoveResult {\n    // Check if it's the piece owner's turn\n    if (piece.owner !== board.currentPlayer) {\n      return {\n        valid: false,\n        error: 'Invalid: not your turn'\n      };\n    }\n\n    // Check if destination is within board boundaries\n    if (!MoveValidator.isWithinBounds(to)) {\n      return {\n        valid: false,\n        error: 'Invalid: out of bounds'\n      };\n    }\n\n    // Validate against piece-specific movement rules first\n    if (!PieceLogic.isValidMove(piece, to, board)) {\n      return {\n        valid: false,\n        error: 'Invalid: illegal move for piece type'\n      };\n    }\n\n    // Check if destination is occupied by friendly piece\n    const pieceAtDestination = GameState.getPieceAt(to, board);\n    if (pieceAtDestination && pieceAtDestination.owner === piece.owner) {\n      return {\n        valid: false,\n        error: 'Invalid: blocked'\n      };\n    }\n\n    // Check path obstruction for pieces that need clear paths\n    if (!MoveValidator.checkPathClear(piece, to, board)) {\n      return {\n        valid: false,\n        error: 'Invalid: obstructed'\n      };\n    }\n\n    // Check capture validation\n    const captureResult = MoveValidator.validateCapture(piece, to, board);\n    if (!captureResult.valid) {\n      return captureResult;\n    }\n\n    // Move is valid - create the new state\n    const move = {\n      piece,\n      from: { ...piece.position },\n      to: { ...to },\n      capturedPiece: pieceAtDestination,\n      timestamp: Date.now()\n    };\n\n    const newState = GameState.applyMove(board, move);\n\n    return {\n      valid: true,\n      newState,\n      move\n    };\n  }\n\n  /**\n   * Get all valid moves for a piece\n   */\n  static getValidMoves(piece: Piece, board: BoardState): Position[] {\n    // Only return moves if it's the piece owner's turn\n    if (piece.owner !== board.currentPlayer) {\n      return [];\n    }\n\n    return PieceLogic.getValidDestinations(piece, board);\n  }\n\n  /**\n   * Check if path is clear between piece position and destination\n   */\n  static isPathClear(from: Position, to: Position, board: BoardState, pieceType: PieceType): boolean {\n    return PieceLogic.isPathClear(from, to, board, pieceType);\n  }\n\n  /**\n   * Check path obstruction for pieces that need clear paths\n   * Knights can jump, so no obstruction check needed\n   */\n  private static checkPathClear(piece: Piece, to: Position, board: BoardState): boolean {\n    // Knights can jump over pieces\n    if (piece.type === PieceType.KNIGHT) {\n      return true;\n    }\n\n    // For Bishops and Queens, check diagonal paths\n    if (piece.type === PieceType.BISHOP || piece.type === PieceType.QUEEN) {\n      return PieceLogic.isPathClear(piece.position, to, board, piece.type);\n    }\n\n    // For Pawns, the getValidDestinations already handles obstruction\n    // by not including occupied squares\n    if (piece.type === PieceType.PAWN) {\n      return true;\n    }\n\n    return true;\n  }\n\n  /**\n   * Validate capture logic\n   */\n  private static validateCapture(piece: Piece, target: Position, board: BoardState): MoveResult {\n    const pieceAtTarget = GameState.getPieceAt(target, board);\n\n    // If no piece at target, no capture validation needed\n    if (!pieceAtTarget) {\n      return { valid: true };\n    }\n\n    // Pawns cannot capture in this game\n    if (piece.type === PieceType.PAWN) {\n      return {\n        valid: false,\n        error: 'Invalid: pawns cannot capture'\n      };\n    }\n\n    // Knights, Bishops, and Queens can capture opponent pieces\n    if (pieceAtTarget.owner !== piece.owner) {\n      return { valid: true };\n    }\n\n    // Should not reach here as friendly piece blocking is checked earlier\n    return {\n      valid: false,\n      error: 'Invalid: blocked'\n    };\n  }\n\n  /**\n   * Validate and process a Pawn upgrade to Queen\n   */\n  static validateUpgrade(pieceId: string, board: BoardState): MoveResult {\n    // Find the piece\n    const piece = board.pieces.find(p => p.id === pieceId);\n    \n    if (!piece) {\n      return {\n        valid: false,\n        error: 'Invalid: piece not found'\n      };\n    }\n\n    // Check if it's the piece owner's turn\n    if (piece.owner !== board.currentPlayer) {\n      return {\n        valid: false,\n        error: 'Invalid: not your turn'\n      };\n    }\n\n    // Check if piece is a Pawn\n    if (piece.type !== PieceType.PAWN) {\n      return {\n        valid: false,\n        error: 'Invalid: only pawns can be upgraded'\n      };\n    }\n\n    // Check if player has at least 2 resource points\n    if (board.resourcePoints[piece.owner] < 2) {\n      return {\n        valid: false,\n        error: 'Invalid: insufficient resource points (need 2)'\n      };\n    }\n\n    // Check if Pawn is not on row 1 or row 8\n    if (piece.position.row === 1 || piece.position.row === 8) {\n      return {\n        valid: false,\n        error: 'Invalid: cannot upgrade pawns on row 1 or row 8'\n      };\n    }\n\n    // Create upgrade move\n    const move = {\n      piece,\n      from: { ...piece.position },\n      to: { ...piece.position },\n      isUpgrade: true,\n      timestamp: Date.now()\n    };\n\n    const newState = GameState.applyMove(board, move);\n\n    return {\n      valid: true,\n      newState,\n      move\n    };\n  }\n\n  /**\n   * Check if position is within board boundaries\n   */\n  private static isWithinBounds(position: Position): boolean {\n    return position.row >= 1 && position.row <= 8 && \n           position.col >= 1 && position.col <= 8;\n  }\n}\n","import { BoardState, GameStatus, Player } from '../types';\nimport { MoveValidator } from './moveValidator';\n\n/**\n * Win and Draw Condition Detection\n * Detects win conditions (piece count, no valid moves) and draw conditions (50-move rule)\n */\nexport class WinConditions {\n  /**\n   * Check the current game status\n   */\n  static checkGameStatus(state: BoardState): GameStatus {\n    // Check draw condition first (50 moves without capture)\n    if (this.isDrawByFiftyMoveRule(state)) {\n      return GameStatus.DRAW;\n    }\n\n    // Check win conditions for both players\n    const player1Pieces = state.pieces.filter(p => p.owner === Player.PLAYER_1);\n    const player2Pieces = state.pieces.filter(p => p.owner === Player.PLAYER_2);\n\n    // Check if Player 1 has fewer than 3 pieces\n    if (player1Pieces.length < 3) {\n      return GameStatus.PLAYER_2_WIN;\n    }\n\n    // Check if Player 2 has fewer than 3 pieces\n    if (player2Pieces.length < 3) {\n      return GameStatus.PLAYER_1_WIN;\n    }\n\n    // Check if current player has no valid moves\n    if (this.hasNoValidMoves(state, state.currentPlayer)) {\n      // Opponent wins\n      return state.currentPlayer === Player.PLAYER_1 \n        ? GameStatus.PLAYER_2_WIN \n        : GameStatus.PLAYER_1_WIN;\n    }\n\n    return GameStatus.IN_PROGRESS;\n  }\n\n  /**\n   * Check if a player has fewer than 3 pieces\n   */\n  static hasInsufficientPieces(state: BoardState, player: Player): boolean {\n    const playerPieces = state.pieces.filter(p => p.owner === player);\n    return playerPieces.length < 3;\n  }\n\n  /**\n   * Check if a player has no valid moves available\n   */\n  static hasNoValidMoves(state: BoardState, player: Player): boolean {\n    const playerPieces = state.pieces.filter(p => p.owner === player);\n\n    // Check each piece to see if it has any valid moves\n    for (const piece of playerPieces) {\n      const validMoves = MoveValidator.getValidMoves(piece, state);\n      if (validMoves.length > 0) {\n        return false; // Found at least one valid move\n      }\n    }\n\n    return true; // No valid moves found for any piece\n  }\n\n  /**\n   * Check if game is a draw by 50-move rule (50 consecutive moves without capture)\n   */\n  static isDrawByFiftyMoveRule(state: BoardState): boolean {\n    return state.capturesSinceLastMove >= 50;\n  }\n\n  /**\n   * Check if the game is over (any win or draw condition)\n   */\n  static isGameOver(state: BoardState): boolean {\n    return this.checkGameStatus(state) !== GameStatus.IN_PROGRESS;\n  }\n\n  /**\n   * Get the winner if there is one\n   */\n  static getWinner(state: BoardState): Player | null {\n    const status = this.checkGameStatus(state);\n    if (status === GameStatus.PLAYER_1_WIN) {\n      return Player.PLAYER_1;\n    }\n    if (status === GameStatus.PLAYER_2_WIN) {\n      return Player.PLAYER_2;\n    }\n    return null;\n  }\n\n  /**\n   * Get a human-readable game outcome message\n   */\n  static getOutcomeMessage(state: BoardState): string {\n    const status = this.checkGameStatus(state);\n    \n    switch (status) {\n      case GameStatus.PLAYER_1_WIN:\n        return 'Player 1 wins!';\n      case GameStatus.PLAYER_2_WIN:\n        return 'Player 2 wins!';\n      case GameStatus.DRAW:\n        return 'Game is a draw (50 moves without capture)';\n      case GameStatus.IN_PROGRESS:\n        return 'Game in progress';\n      default:\n        return 'Unknown game status';\n    }\n  }\n}\n","import { BoardState, Move, Player, Position, Piece, PieceType, GameStatus } from '../types';\nimport { GameState } from './gameState';\nimport { WinConditions } from './winConditions';\n\n/**\n * Game State Manager with History and Undo\n * Manages the complete game state including move history and undo functionality\n */\nexport class GameStateManager {\n  private currentState: BoardState;\n  private moveHistory: Move[];\n  private stateHistory: BoardState[];\n\n  constructor(initialState?: BoardState) {\n    this.currentState = initialState || GameState.initializeBoard();\n    this.moveHistory = [];\n    this.stateHistory = [GameState.cloneState(this.currentState)];\n  }\n\n  /**\n   * Get the current board state\n   */\n  getCurrentState(): BoardState {\n    return GameState.cloneState(this.currentState);\n  }\n\n  /**\n   * Get the complete move history\n   */\n  getMoveHistory(): Move[] {\n    return [...this.moveHistory];\n  }\n\n  /**\n   * Record a move and update the game state\n   */\n  recordMove(move: Move): void {\n    // Apply the move to get new state\n    this.currentState = GameState.applyMove(this.currentState, move);\n    \n    // Record the move in history\n    this.moveHistory.push(move);\n    \n    // Save state snapshot for undo\n    this.stateHistory.push(GameState.cloneState(this.currentState));\n  }\n\n  /**\n   * Undo the last N moves (up to 3)\n   */\n  undoMoves(count: number): boolean {\n    // Validate count\n    if (count < 1) {\n      return false;\n    }\n\n    // Limit to available moves\n    const actualCount = Math.min(count, this.moveHistory.length, 3);\n    \n    if (actualCount === 0) {\n      return false;\n    }\n\n    // Remove moves from history\n    this.moveHistory.splice(-actualCount);\n    \n    // Remove state snapshots\n    this.stateHistory.splice(-actualCount);\n    \n    // Restore the state from the last snapshot\n    if (this.stateHistory.length > 0) {\n      this.currentState = GameState.cloneState(\n        this.stateHistory[this.stateHistory.length - 1]\n      );\n    }\n\n    return true;\n  }\n\n  /**\n   * Get the state at a specific point in history\n   */\n  getStateAtMove(moveIndex: number): BoardState | null {\n    if (moveIndex < 0 || moveIndex >= this.stateHistory.length) {\n      return null;\n    }\n    return GameState.cloneState(this.stateHistory[moveIndex]);\n  }\n\n  /**\n   * Reset the game to initial state\n   */\n  reset(): void {\n    this.currentState = GameState.initializeBoard();\n    this.moveHistory = [];\n    this.stateHistory = [GameState.cloneState(this.currentState)];\n  }\n\n  /**\n   * Get the number of moves in history\n   */\n  getMoveCount(): number {\n    return this.moveHistory.length;\n  }\n\n  /**\n   * Check if undo is available\n   */\n  canUndo(count: number = 1): boolean {\n    return this.moveHistory.length >= count && count <= 3;\n  }\n\n  /**\n   * Check if a piece can be upgraded\n   */\n  canUpgradePiece(pieceId: string): boolean {\n    const piece = this.currentState.pieces.find(p => p.id === pieceId);\n    \n    if (!piece) return false;\n    if (piece.type !== PieceType.PAWN) return false;\n    if (piece.owner !== this.currentState.currentPlayer) return false;\n    if (this.currentState.resourcePoints[piece.owner] < 2) return false;\n    if (piece.position.row === 1 || piece.position.row === 8) return false;\n    \n    return true;\n  }\n\n  /**\n   * Get current resource points for a player\n   */\n  getResourcePoints(player: Player): number {\n    return this.currentState.resourcePoints[player];\n  }\n\n  /**\n   * Upgrade a Pawn to a Queen\n   * Returns the move if successful, null otherwise\n   */\n  upgradePiece(pieceId: string): Move | null {\n    // Validate upgrade is possible\n    if (!this.canUpgradePiece(pieceId)) {\n      return null;\n    }\n\n    const piece = this.currentState.pieces.find(p => p.id === pieceId);\n    if (!piece) {\n      return null;\n    }\n\n    // Create upgrade move\n    const upgradeMove: Move = {\n      piece: { ...piece },\n      from: { ...piece.position },\n      to: { ...piece.position },\n      isUpgrade: true,\n      timestamp: Date.now()\n    };\n\n    // Record the move (this will apply the upgrade and deduct resources)\n    this.recordMove(upgradeMove);\n\n    return upgradeMove;\n  }\n\n  /**\n   * Get the current game status (in progress, win, or draw)\n   */\n  getGameStatus(): GameStatus {\n    return WinConditions.checkGameStatus(this.currentState);\n  }\n\n  /**\n   * Check if the game is over\n   */\n  isGameOver(): boolean {\n    return WinConditions.isGameOver(this.currentState);\n  }\n\n  /**\n   * Get the winner if there is one\n   */\n  getWinner(): Player | null {\n    return WinConditions.getWinner(this.currentState);\n  }\n\n  /**\n   * Get a human-readable game outcome message\n   */\n  getOutcomeMessage(): string {\n    return WinConditions.getOutcomeMessage(this.currentState);\n  }\n\n  /**\n   * Check if a move can be made (game is not over)\n   */\n  canMakeMove(): boolean {\n    return !this.isGameOver();\n  }\n}\n","import { BoardState, Move, Player, PieceType, Difficulty } from '../types';\nimport { MoveValidator } from './moveValidator';\nimport { PieceLogic } from './pieceLogic';\n\nexport class AIEngine {\n  private static readonly TIME_LIMIT_MS = 5000; // 5 seconds\n\n  static getPieceValue(type: PieceType): number {\n    switch (type) {\n      case PieceType.PAWN:\n        return 10;\n      case PieceType.KNIGHT:\n        return 30;\n      case PieceType.BISHOP:\n        return 30;\n      case PieceType.QUEEN:\n        return 50;\n    }\n  }\n\n  static orderMoves(moves: Move[], board: BoardState): Move[] {\n    return moves.sort((a, b) => {\n      const aIsCapture = a.capturedPiece !== undefined;\n      const bIsCapture = b.capturedPiece !== undefined;\n      \n      if (aIsCapture && !bIsCapture) return -1;\n      if (!aIsCapture && bIsCapture) return 1;\n      \n      if (aIsCapture && bIsCapture) {\n        const aValue = this.getPieceValue(a.capturedPiece!.type);\n        const bValue = this.getPieceValue(b.capturedPiece!.type);\n        if (aValue !== bValue) return bValue - aValue;\n      }\n\n      const aIsUpgrade = a.isUpgrade === true;\n      const bIsUpgrade = b.isUpgrade === true;\n      \n      if (aIsUpgrade && !bIsUpgrade) return -1;\n      if (!aIsUpgrade && bIsUpgrade) return 1;\n\n      const aForwardProgress = this.getForwardProgress(a);\n      const bForwardProgress = this.getForwardProgress(b);\n      \n      if (aForwardProgress !== bForwardProgress) {\n        return bForwardProgress - aForwardProgress;\n      }\n\n      return 0;\n    });\n  }\n\n  private static getForwardProgress(move: Move): number {\n    const piece = move.piece;\n    const fromRow = move.from.row;\n    const toRow = move.to.row;\n    \n    if (piece.owner === Player.PLAYER_1) {\n      return toRow - fromRow;\n    } else {\n      return fromRow - toRow;\n    }\n  }\n\n  static generateMoves(board: BoardState, player: Player): Move[] {\n    const moves: Move[] = [];\n    const playerPieces = board.pieces.filter(p => p.owner === player);\n\n    for (const piece of playerPieces) {\n      const validDestinations = PieceLogic.getValidDestinations(piece, board);\n      \n      for (const destination of validDestinations) {\n        const result = MoveValidator.validateMove(piece, destination, board);\n        \n        if (result.valid && result.move) {\n          moves.push(result.move);\n        }\n      }\n    }\n\n    return moves;\n  }\n\n  static getDepthForDifficulty(difficulty: Difficulty): number {\n    switch (difficulty) {\n      case Difficulty.EASY:\n        return 4;\n      case Difficulty.HARD:\n        return 6;\n    }\n  }\n\n  static calculateBestMove(board: BoardState, difficulty: Difficulty): Move | null {\n    const depth = this.getDepthForDifficulty(difficulty);\n    const startTime = Date.now();\n    \n    const moves = this.generateMoves(board, board.currentPlayer);\n    \n    if (moves.length === 0) {\n      return null;\n    }\n\n    const orderedMoves = this.orderMoves(moves, board);\n    let bestMove = orderedMoves[0];\n    \n    // Return first move if time limit is already exceeded\n    if (Date.now() - startTime >= this.TIME_LIMIT_MS) {\n      return bestMove;\n    }\n\n    // For now, return the best ordered move\n    // This will be enhanced with minimax in task 7.1\n    return bestMove;\n  }\n}\n","import { BoardState, GameConfig, GameMode, GameStatus, Move, MoveResult, Player, Position, Difficulty, Piece } from '../types';\nimport { GameStateManager } from './gameStateManager';\nimport { MoveValidator } from './moveValidator';\nimport { AIEngine } from './aiEngine';\nimport { WinConditions } from './winConditions';\n\n/**\n * GameController\n * Orchestrates game flow, turn management, move processing, AI triggering,\n * game mode switching, undo requests, and win/draw condition detection\n */\nexport class GameController {\n  private stateManager: GameStateManager;\n  private config: GameConfig;\n\n  constructor(config?: GameConfig) {\n    this.config = config || { mode: GameMode.PVP, difficulty: Difficulty.EASY };\n    this.stateManager = new GameStateManager();\n  }\n\n  /**\n   * Initialize a new game with the given configuration\n   */\n  initializeGame(config: GameConfig): void {\n    this.config = config;\n    this.stateManager.reset();\n  }\n\n  /**\n   * Get the current game configuration\n   */\n  getConfig(): GameConfig {\n    return { ...this.config };\n  }\n\n  /**\n   * Get the current board state\n   */\n  getGameState(): BoardState {\n    return this.stateManager.getCurrentState();\n  }\n\n  /**\n   * Get the current game status\n   */\n  getGameStatus(): GameStatus {\n    return this.stateManager.getGameStatus();\n  }\n\n  /**\n   * Get the complete move history\n   */\n  getMoveHistory(): Move[] {\n    return this.stateManager.getMoveHistory();\n  }\n\n  /**\n   * Check if the game is over\n   */\n  isGameOver(): boolean {\n    return this.stateManager.isGameOver();\n  }\n\n  /**\n   * Get the winner if there is one\n   */\n  getWinner(): Player | null {\n    return this.stateManager.getWinner();\n  }\n\n  /**\n   * Get a human-readable game outcome message\n   */\n  getOutcomeMessage(): string {\n    return this.stateManager.getOutcomeMessage();\n  }\n\n  /**\n   * Attempt to make a move from one position to another\n   * Returns the result of the move attempt\n   */\n  attemptMove(from: Position, to: Position): MoveResult {\n    // Check if game is over\n    if (this.isGameOver()) {\n      return {\n        valid: false,\n        error: 'Invalid: game over'\n      };\n    }\n\n    const currentState = this.stateManager.getCurrentState();\n    \n    // Find the piece at the from position\n    const piece = currentState.pieces.find(\n      p => p.position.row === from.row && p.position.col === from.col\n    );\n\n    if (!piece) {\n      return {\n        valid: false,\n        error: 'Invalid: no piece at source position'\n      };\n    }\n\n    // Validate the move\n    const result = MoveValidator.validateMove(piece, to, currentState);\n\n    if (result.valid && result.move) {\n      // Record the move\n      this.stateManager.recordMove(result.move);\n\n      // Check if AI should make a move\n      if (this.shouldTriggerAI()) {\n        this.triggerAIMove();\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Attempt to upgrade a pawn to a queen\n   */\n  attemptUpgrade(pieceId: string): MoveResult {\n    // Check if game is over\n    if (this.isGameOver()) {\n      return {\n        valid: false,\n        error: 'Invalid: game over'\n      };\n    }\n\n    const currentState = this.stateManager.getCurrentState();\n    \n    // Validate the upgrade\n    const result = MoveValidator.validateUpgrade(pieceId, currentState);\n\n    if (result.valid && result.move) {\n      // Record the upgrade move\n      this.stateManager.recordMove(result.move);\n    }\n\n    return result;\n  }\n\n  /**\n   * Undo the last N moves (up to 3)\n   */\n  undoMove(count: number = 1): boolean {\n    if (this.isGameOver()) {\n      return false;\n    }\n\n    return this.stateManager.undoMoves(count);\n  }\n\n  /**\n   * Switch game mode and reset the board\n   */\n  switchMode(newConfig: GameConfig): void {\n    this.config = newConfig;\n    this.stateManager.reset();\n  }\n\n  /**\n   * Start a new game with the same configuration\n   */\n  restartGame(): void {\n    this.stateManager.reset();\n  }\n\n  /**\n   * Start a new game with a different configuration\n   */\n  newGame(config: GameConfig): void {\n    this.config = config;\n    this.stateManager.reset();\n  }\n\n  /**\n   * Get the state at a specific point in history\n   */\n  getStateAtMove(moveIndex: number): BoardState | null {\n    return this.stateManager.getStateAtMove(moveIndex);\n  }\n\n  /**\n   * Check if undo is available\n   */\n  canUndo(count: number = 1): boolean {\n    return this.stateManager.canUndo(count);\n  }\n\n  /**\n   * Check if a piece can be upgraded\n   */\n  canUpgradePiece(pieceId: string): boolean {\n    return this.stateManager.canUpgradePiece(pieceId);\n  }\n\n  /**\n   * Get current resource points for a player\n   */\n  getResourcePoints(player: Player): number {\n    return this.stateManager.getResourcePoints(player);\n  }\n\n  /**\n   * Check if AI should make a move after the current move\n   */\n  private shouldTriggerAI(): boolean {\n    // AI should move if:\n    // 1. Game mode is AI\n    // 2. Current player is Player 2 (AI player)\n    // 3. Game is not over\n    if (this.config.mode !== GameMode.AI) {\n      return false;\n    }\n\n    const currentState = this.stateManager.getCurrentState();\n    if (currentState.currentPlayer !== Player.PLAYER_2) {\n      return false;\n    }\n\n    if (this.isGameOver()) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Trigger AI to make a move\n   */\n  private triggerAIMove(): void {\n    const currentState = this.stateManager.getCurrentState();\n    const difficulty = this.config.difficulty || Difficulty.EASY;\n\n    // Calculate best move\n    const bestMove = AIEngine.calculateBestMove(currentState, difficulty);\n\n    if (bestMove) {\n      // Record the AI's move\n      this.stateManager.recordMove(bestMove);\n    }\n  }\n\n  /**\n   * Get the current player\n   */\n  getCurrentPlayer(): Player {\n    return this.stateManager.getCurrentState().currentPlayer;\n  }\n\n  /**\n   * Check if it's the AI's turn\n   */\n  isAITurn(): boolean {\n    return this.config.mode === GameMode.AI && \n           this.getCurrentPlayer() === Player.PLAYER_2;\n  }\n\n  /**\n   * Get the current game mode\n   */\n  getGameMode(): GameMode {\n    return this.config.mode;\n  }\n\n  /**\n   * Get the current difficulty setting\n   */\n  getDifficulty(): Difficulty {\n    return this.config.difficulty || Difficulty.EASY;\n  }\n\n  /**\n   * Get valid moves for a piece\n   */\n  getValidMoves(piece: Piece): Position[] {\n    const currentState = this.stateManager.getCurrentState();\n    return MoveValidator.getValidMoves(piece, currentState);\n  }\n}\n"],"names":["PieceType","Player","GameStatus","Difficulty","GameMode","GameState","pieces","state","move","newPieces","p","capturedIndex","movingPieceIndex","newResourcePoints","isUpgradeOnly","nextPlayer","position","PawnLogic","pawn","board","validPositions","direction","row","col","oneSquareAhead","twoSquaresAhead","piece","promotionRow","to","pos","KnightLogic","knight","moves","pieceAtDestination","target","pieceAtTarget","BishopLogic","bishop","directions","currentRow","currentCol","currentPos","pieceAtPos","from","rowDiff","colDiff","rowStep","colStep","steps","i","checkPos","QueenLogic","queen","diagonalDirections","forwardDirections","allDirections","PieceLogic","pieceType","MoveValidator","captureResult","pieceId","WinConditions","player1Pieces","player2Pieces","player","playerPieces","status","GameStateManager","initialState","count","actualCount","moveIndex","upgradeMove","_AIEngine","type","a","b","aIsCapture","bIsCapture","aValue","bValue","aIsUpgrade","bIsUpgrade","aForwardProgress","bForwardProgress","fromRow","toRow","validDestinations","destination","result","difficulty","startTime","bestMove","AIEngine","GameController","config","currentState","newConfig"],"mappings":"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"}